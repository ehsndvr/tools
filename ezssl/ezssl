#!/usr/bin/env bash
set -euo pipefail

# EHSNDVR EZSSL: one-command SSL setup for Nginx reverse proxy.

TAG="EHSNDVR"
DOMAIN=""
PORT=""
EMAIL=""
APP_HOST=""
SERVER_IP=""
SSL_CERT_PATH=""
SSL_CERT_ONLY_PATH=""
SSL_KEY_PATH=""
SSL_CHAIN_PATH=""
USER_PEM_PATH=""
USER_KEY_PATH=""
NON_INTERACTIVE="false"
USE_MENU="false"
FORCE_CLEANUP_FIRST="false"
CLEANUP_ONLY="false"
TTY_FD=0
USE_COLOR="false"
STATE_DIR="/etc/ezssl"
CACHE_FILE="/etc/ezssl/cache.env"
REGISTRY_FILE="/etc/ezssl/registry.tsv"
USER_CERTS_DIR="/root"
CACHED_PORT=""
CACHED_EMAIL=""
CACHED_APP_HOST=""
EXISTING_PORT=""
EXISTING_APP_HOST=""
EXISTING_EMAIL=""
EXISTING_FOUND="false"

RED=""
GREEN=""
YELLOW=""
BLUE=""
CYAN=""
BOLD=""
NC=""

log() {
  echo -e "[${TAG}] $*"
}

ok() {
  echo -e "${GREEN}[${TAG}] $*${NC}"
}

warn() {
  echo -e "${YELLOW}[${TAG}] $*${NC}"
}

err() {
  echo -e "${RED}[${TAG}] $*${NC}" >&2
}

usage() {
  cat <<USAGE
EHSNDVR EZSSL - Nginx + Let's Encrypt assistant

Usage:
  $0 [options]

Options:
  --domain <domain>       Domain name (example.com)
  --port <port>           Backend app port (1-65535)
  --email <email>         Email for Let's Encrypt registration
  --app-host <host>       Backend app host (default: server primary IP)
  --menu                  Open interactive menu
  --non-interactive       Run without prompts (auto-installs dependencies)
  --cleanup-first         Remove existing domain SSL/Nginx config, then install
  --cleanup-only          Remove existing domain SSL/Nginx config, then exit
  -h, --help              Show this help

Examples:
  $0
  $0 --domain app.example.com --port 3000 --email you@example.com
USAGE
}

require_root() {
  if [[ "${EUID}" -ne 0 ]]; then
    err "Please run as root (sudo)."
    exit 1
  fi
}

command_exists() {
  command -v "$1" >/dev/null 2>&1
}

ensure_state_dir() {
  mkdir -p "${STATE_DIR}"
  mkdir -p "${USER_CERTS_DIR}"
  chmod 700 "${STATE_DIR}" >/dev/null 2>&1 || true
  chmod 700 "${USER_CERTS_DIR}" >/dev/null 2>&1 || true
}

load_cache() {
  if [[ ! -f "${CACHE_FILE}" ]]; then
    return
  fi

  CACHED_PORT="$(awk -F= '/^PORT=/{print $2}' "${CACHE_FILE}" 2>/dev/null | tr -d '"' || true)"
  CACHED_EMAIL="$(awk -F= '/^EMAIL=/{print $2}' "${CACHE_FILE}" 2>/dev/null | tr -d '"' || true)"
  CACHED_APP_HOST="$(awk -F= '/^APP_HOST=/{print $2}' "${CACHE_FILE}" 2>/dev/null | tr -d '"' || true)"
}

save_cache() {
  cat > "${CACHE_FILE}" <<EOF
PORT="${PORT}"
EMAIL="${EMAIL}"
APP_HOST="${APP_HOST}"
EOF
  chmod 600 "${CACHE_FILE}" >/dev/null 2>&1 || true
}

remove_registry_entry() {
  if [[ ! -f "${REGISTRY_FILE}" ]]; then
    return
  fi

  awk -F'|' -v d="${DOMAIN}" '$1 != d {print $0}' "${REGISTRY_FILE}" > "${REGISTRY_FILE}.tmp"
  mv "${REGISTRY_FILE}.tmp" "${REGISTRY_FILE}"
}

save_registry_entry() {
  local ts=""
  ts="$(date -u +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date)"

  touch "${REGISTRY_FILE}"
  remove_registry_entry
  printf '%s|%s|%s|%s|%s\n' "${DOMAIN}" "${PORT}" "${APP_HOST}" "${EMAIL}" "${ts}" >> "${REGISTRY_FILE}"
  chmod 600 "${REGISTRY_FILE}" >/dev/null 2>&1 || true
}

load_existing_entry() {
  local line=""
  EXISTING_PORT=""
  EXISTING_APP_HOST=""
  EXISTING_EMAIL=""
  EXISTING_FOUND="false"

  if [[ -f "${REGISTRY_FILE}" ]]; then
    line="$(awk -F'|' -v d="${DOMAIN}" '$1 == d {print $0; exit}' "${REGISTRY_FILE}")"
    if [[ -n "${line}" ]]; then
      EXISTING_PORT="$(echo "${line}" | awk -F'|' '{print $2}')"
      EXISTING_APP_HOST="$(echo "${line}" | awk -F'|' '{print $3}')"
      EXISTING_EMAIL="$(echo "${line}" | awk -F'|' '{print $4}')"
      EXISTING_FOUND="true"
    fi
  fi
}

init_output_style() {
  if [[ -t 1 ]]; then
    USE_COLOR="true"
    RED=$'\033[0;31m'
    GREEN=$'\033[0;32m'
    YELLOW=$'\033[1;33m'
    BLUE=$'\033[0;34m'
    CYAN=$'\033[0;36m'
    BOLD=$'\033[1m'
    NC=$'\033[0m'
  fi
}

detect_server_ip() {
  local ip_candidate=""
  local ip_json=""

  if command_exists curl; then
    ip_json="$(curl -4fsS --max-time 4 'https://api.ipify.org?format=json' 2>/dev/null || true)"
    if [[ -n "${ip_json}" ]]; then
      ip_candidate="$(echo "${ip_json}" | sed -n 's/.*"ip"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')"
    fi

    if [[ -z "${ip_candidate}" ]]; then
      ip_json="$(curl -fsS --max-time 4 'https://api64.ipify.org?format=json' 2>/dev/null || true)"
      if [[ -n "${ip_json}" ]]; then
        ip_candidate="$(echo "${ip_json}" | sed -n 's/.*"ip"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')"
      fi
    fi
  fi

  if command_exists ip; then
    if [[ -z "${ip_candidate}" ]]; then
      ip_candidate="$(ip -4 route get 1.1.1.1 2>/dev/null | awk '/src/ {for (i=1; i<=NF; i++) if ($i == "src") {print $(i+1); exit}}')"
    fi
  fi

  if [[ -z "${ip_candidate}" ]]; then
    ip_candidate="$(hostname -I 2>/dev/null | awk '{print $1}')"
  fi

  if [[ -z "${ip_candidate}" ]]; then
    ip_candidate="127.0.0.1"
  fi

  SERVER_IP="${ip_candidate}"
}

default_app_host() {
  if [[ -n "${CACHED_APP_HOST}" ]]; then
    echo "${CACHED_APP_HOST}"
  else
    echo "${SERVER_IP}"
  fi
}

apply_noninteractive_cache_defaults() {
  if [[ -z "${PORT}" && -n "${CACHED_PORT}" ]]; then
    PORT="${CACHED_PORT}"
    log "Using cached port: ${PORT}"
  fi

  if [[ -z "${EMAIL}" && -n "${CACHED_EMAIL}" ]]; then
    EMAIL="${CACHED_EMAIL}"
    log "Using cached email: ${EMAIL}"
  fi

  if [[ -z "${APP_HOST}" ]]; then
    APP_HOST="$(default_app_host)"
    log "Using default app host: ${APP_HOST}"
  fi
}

setup_tty() {
  if [[ -t 0 ]]; then
    TTY_FD=0
    return
  fi

  if [[ -r /dev/tty ]]; then
    exec 3</dev/tty
    TTY_FD=3
    return
  fi

  err "Interactive mode needs a TTY. Use --non-interactive with flags."
  exit 1
}

prompt_line() {
  local label="$1"
  local default="${2:-}"
  local value=""

  if [[ -n "${default}" ]]; then
    read -r -u "${TTY_FD}" -p "${label} [${default}]: " value || true
    if [[ -z "${value}" ]]; then
      value="${default}"
    fi
  else
    read -r -u "${TTY_FD}" -p "${label}: " value || true
  fi

  echo "${value}"
}

show_banner() {
  if [[ -t 1 ]]; then
    clear || true
  fi
  cat <<BANNER
${CYAN}${BOLD}
=====================================================
                EHSNDVR EZSSL ASSISTANT
      Nginx Reverse Proxy + Let's Encrypt SSL
=====================================================
${NC}
BANNER
}

show_menu() {
  show_banner
  cat <<MENU
${BLUE}${BOLD}Choose an option:${NC}
  1) Setup SSL (domain + port)
  2) Show help
  3) Exit
MENU
}

run_interactive_menu() {
  local choice=""
  while true; do
    show_menu
    choice="$(prompt_line "Enter choice (1-3)")"
    case "${choice}" in
      1)
        DOMAIN="$(prompt_line "Domain (e.g. app.example.com)")"
        PORT="$(prompt_line "Backend app port (e.g. 3000)" "${CACHED_PORT}")"
        EMAIL="$(prompt_line "Email for Let's Encrypt" "${CACHED_EMAIL}")"
        APP_HOST="$(prompt_line "Backend app host" "$(default_app_host)")"
        break
        ;;
      2)
        usage
        echo
        read -r -u "${TTY_FD}" -p "Press Enter to return to menu..." _ || true
        ;;
      3)
        log "Exit."
        exit 0
        ;;
      *)
        warn "Invalid choice. Please select 1, 2, or 3."
        sleep 1
        ;;
    esac
  done
}

prompt_if_missing() {
  if [[ -z "${DOMAIN}" ]]; then
    DOMAIN="$(prompt_line "Domain (e.g. app.example.com)")"
  fi

  if [[ -z "${PORT}" ]]; then
    PORT="$(prompt_line "Backend app port (e.g. 3000)" "${CACHED_PORT}")"
  fi

  if [[ -z "${EMAIL}" ]]; then
    EMAIL="$(prompt_line "Email for Let's Encrypt" "${CACHED_EMAIL}")"
  fi

  if [[ -z "${APP_HOST}" ]]; then
    APP_HOST="$(prompt_line "Backend app host" "$(default_app_host)")"
  fi
}

enforce_domain_port_uniqueness() {
  local conflict_line=""
  local conflict_domain=""

  if [[ ! -f "${REGISTRY_FILE}" ]]; then
    return
  fi

  conflict_line="$(awk -F'|' -v p="${PORT}" -v d="${DOMAIN}" '$2 == p && $1 != d {print $0; exit}' "${REGISTRY_FILE}")"
  if [[ -n "${conflict_line}" ]]; then
    conflict_domain="$(echo "${conflict_line}" | awk -F'|' '{print $1}')"
    err "Port ${PORT} is already used by domain ${conflict_domain}. Use a different port."
    exit 1
  fi
}

resolve_ssl_paths() {
  SSL_CERT_PATH="/etc/letsencrypt/live/${DOMAIN}/fullchain.pem"
  SSL_CERT_ONLY_PATH="/etc/letsencrypt/live/${DOMAIN}/cert.pem"
  SSL_KEY_PATH="/etc/letsencrypt/live/${DOMAIN}/privkey.pem"
  SSL_CHAIN_PATH="/etc/letsencrypt/live/${DOMAIN}/chain.pem"
}

create_user_ssl_files() {
  resolve_ssl_paths

  USER_PEM_PATH="${USER_CERTS_DIR}/${DOMAIN}.pem"
  USER_KEY_PATH="${USER_CERTS_DIR}/${DOMAIN}.key"
  local cert_source=""

  if [[ -e "${SSL_CERT_PATH}" ]]; then
    cert_source="${SSL_CERT_PATH}"
  elif [[ -e "${SSL_CERT_ONLY_PATH}" ]]; then
    cert_source="${SSL_CERT_ONLY_PATH}"
  fi

  if [[ -n "${cert_source}" ]]; then
    cp -f "${cert_source}" "${USER_PEM_PATH}"
    chmod 600 "${USER_PEM_PATH}" >/dev/null 2>&1 || true
  else
    warn "Could not find certificate file for ${DOMAIN} in /etc/letsencrypt/live/${DOMAIN}"
  fi

  if [[ -e "${SSL_KEY_PATH}" ]]; then
    cp -f "${SSL_KEY_PATH}" "${USER_KEY_PATH}"
    chmod 600 "${USER_KEY_PATH}" >/dev/null 2>&1 || true
  else
    warn "Could not find private key file for ${DOMAIN} in /etc/letsencrypt/live/${DOMAIN}"
  fi
}

show_service_info() {
  local shown_port="$1"
  local shown_host="$2"
  local shown_email="$3"

  resolve_ssl_paths
  create_user_ssl_files

  cat <<INFO

[${TAG}] Service details for ${DOMAIN}
- Domain: ${DOMAIN}
- Server IP: ${SERVER_IP}
- Backend: http://${shown_host}:${shown_port}
- Email: ${shown_email}
- Nginx config: ${CONF_FILE}
- SSL pem: ${USER_PEM_PATH}
- SSL key: ${USER_KEY_PATH}

Copy-ready paths:
PEM='${USER_PEM_PATH}'
PRIVKEY='${USER_KEY_PATH}'
INFO
}

validate_inputs() {
  if [[ -z "${DOMAIN}" || -z "${PORT}" || -z "${EMAIL}" ]]; then
    err "Missing required values. Use --help for options."
    exit 1
  fi

  if [[ ! "${DOMAIN}" =~ ^[A-Za-z0-9.-]+$ ]]; then
    err "Invalid domain format: ${DOMAIN}"
    exit 1
  fi

  if [[ ! "${PORT}" =~ ^[0-9]+$ ]] || (( PORT < 1 || PORT > 65535 )); then
    err "Port must be a number between 1 and 65535."
    exit 1
  fi

  if [[ ! "${EMAIL}" =~ ^[^@[:space:]]+@[^@[:space:]]+\.[^@[:space:]]+$ ]]; then
    err "Invalid email format: ${EMAIL}"
    exit 1
  fi

  if [[ ! "${APP_HOST}" =~ ^[A-Za-z0-9._:-]+$ ]]; then
    err "Invalid app host format: ${APP_HOST}"
    exit 1
  fi
}

install_packages_if_needed() {
  local missing=()

  command_exists nginx || missing+=("nginx")
  command_exists certbot || missing+=("certbot")

  # certbot nginx plugin names differ by distro
  if ! dpkg -s python3-certbot-nginx >/dev/null 2>&1 &&
     ! rpm -q python3-certbot-nginx >/dev/null 2>&1 &&
     ! rpm -q certbot-nginx >/dev/null 2>&1; then
    missing+=("certbot-nginx-plugin")
  fi

  if (( ${#missing[@]} == 0 )); then
    return
  fi

  warn "Missing dependencies: ${missing[*]}"

  if [[ "${NON_INTERACTIVE}" != "true" ]]; then
    INSTALL_CONFIRM="$(prompt_line "Try to install missing packages automatically? [Y/n]" "Y")"
    INSTALL_CONFIRM="${INSTALL_CONFIRM:-Y}"
    if [[ ! "${INSTALL_CONFIRM}" =~ ^[Yy]$ ]]; then
      err "Install required packages and re-run."
      exit 1
    fi
  else
    log "Non-interactive mode: auto-installing missing dependencies."
  fi

  if command_exists apt-get; then
    apt-get update
    apt-get install -y nginx certbot python3-certbot-nginx
  elif command_exists dnf; then
    dnf install -y nginx certbot python3-certbot-nginx
  elif command_exists yum; then
    yum install -y epel-release || true
    yum install -y nginx certbot python3-certbot-nginx || yum install -y nginx certbot certbot-nginx
  else
    err "Unsupported package manager. Install nginx, certbot, and certbot nginx plugin manually."
    exit 1
  fi
}

resolve_nginx_paths() {
  if [[ -d /etc/nginx/sites-available && -d /etc/nginx/sites-enabled ]]; then
    NGINX_CONF_DIR="/etc/nginx/sites-available"
    NGINX_ENABLE_DIR="/etc/nginx/sites-enabled"
    CONF_FILE="${NGINX_CONF_DIR}/${DOMAIN}.conf"
    ENABLE_FILE="${NGINX_ENABLE_DIR}/${DOMAIN}.conf"
  elif [[ -d /etc/nginx/conf.d ]]; then
    NGINX_CONF_DIR="/etc/nginx/conf.d"
    NGINX_ENABLE_DIR=""
    CONF_FILE="${NGINX_CONF_DIR}/${DOMAIN}.conf"
    ENABLE_FILE=""
  else
    err "Unable to find a standard Nginx config directory."
    exit 1
  fi
}

cleanup_domain_artifacts() {
  log "Cleaning existing artifacts for domain: ${DOMAIN}"

  if [[ -n "${ENABLE_FILE}" && -e "${ENABLE_FILE}" ]]; then
    rm -f "${ENABLE_FILE}"
    log "Removed Nginx enabled link: ${ENABLE_FILE}"
  fi

  if [[ -e "${CONF_FILE}" ]]; then
    rm -f "${CONF_FILE}"
    log "Removed Nginx config: ${CONF_FILE}"
  fi

  if command_exists certbot; then
    certbot delete --cert-name "${DOMAIN}" --non-interactive >/dev/null 2>&1 || true
  fi

  remove_registry_entry

  rm -rf "/etc/letsencrypt/live/${DOMAIN}" \
         "/etc/letsencrypt/archive/${DOMAIN}" \
         "/etc/letsencrypt/renewal/${DOMAIN}.conf"

  if nginx -t; then
    systemctl reload nginx >/dev/null 2>&1 || true
  fi

  ok "Cleanup complete for ${DOMAIN}"
}

handle_existing_installation() {
  local has_nginx="false"
  local has_cert="false"
  local choice=""
  local shown_port="${PORT}"
  local shown_host="${APP_HOST}"
  local shown_email="${EMAIL}"

  if [[ -e "${CONF_FILE}" || ( -n "${ENABLE_FILE}" && -e "${ENABLE_FILE}" ) ]]; then
    has_nginx="true"
  fi

  if [[ -e "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" || -e "/etc/letsencrypt/live/${DOMAIN}/cert.pem" ]]; then
    has_cert="true"
  fi

  if [[ "${has_nginx}" != "true" && "${has_cert}" != "true" ]]; then
    return
  fi

  warn "Existing setup detected for ${DOMAIN}"
  if [[ "${has_nginx}" == "true" ]]; then
    warn "- Existing Nginx config found"
  fi
  if [[ "${has_cert}" == "true" ]]; then
    warn "- Existing Let's Encrypt certificate found"
  fi

  if [[ "${CLEANUP_ONLY}" == "true" ]]; then
    cleanup_domain_artifacts
    exit 0
  fi

  if [[ "${FORCE_CLEANUP_FIRST}" == "true" ]]; then
    cleanup_domain_artifacts
    return
  fi

  load_existing_entry
  if [[ "${EXISTING_FOUND}" == "true" ]]; then
    shown_port="${EXISTING_PORT:-${shown_port}}"
    shown_host="${EXISTING_APP_HOST:-${shown_host}}"
    shown_email="${EXISTING_EMAIL:-${shown_email}}"
  fi
  show_service_info "${shown_port}" "${shown_host}" "${shown_email}"

  if [[ "${NON_INTERACTIVE}" == "true" ]]; then
    ok "Domain ${DOMAIN} is already configured. Nothing changed."
    log "Use --cleanup-first to replace, or --cleanup-only to remove."
    exit 0
  fi

  cat <<MENU

[${TAG}] Existing setup options:
  1) Keep existing setup and exit
  2) Cleanup everything for this domain, then reinstall
  3) Cleanup everything for this domain, then exit
  4) Overwrite/renew existing setup now
MENU
  choice="$(prompt_line "Choose (1-4)" "1")"

  case "${choice}" in
    1)
      ok "Domain ${DOMAIN} is already configured. Nothing changed."
      exit 0
      ;;
    2)
      cleanup_domain_artifacts
      ;;
    3)
      cleanup_domain_artifacts
      exit 0
      ;;
    4)
      log "Continuing with overwrite/renew flow."
      ;;
    *)
      err "Invalid choice."
      exit 1
      ;;
  esac
}

write_nginx_config() {
  cat > "${CONF_FILE}" <<CONF
# Managed by ${TAG}
server {
    listen 80;
    listen [::]:80;
    server_name ${DOMAIN};

    client_max_body_size 64m;

    location / {
        proxy_pass http://${APP_HOST}:${PORT};
        proxy_http_version 1.1;

        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
CONF

  if [[ -n "${ENABLE_FILE}" ]]; then
    ln -sfn "${CONF_FILE}" "${ENABLE_FILE}"
  fi

  if nginx -t; then
    systemctl enable nginx >/dev/null 2>&1 || true
    systemctl reload nginx
    ok "Nginx config created and reloaded for ${DOMAIN}"
  else
    err "Nginx configuration test failed."
    exit 1
  fi
}

request_certificate() {
  log "Requesting SSL certificate from Let's Encrypt..."

  certbot --nginx \
    -d "${DOMAIN}" \
    --non-interactive \
    --agree-tos \
    -m "${EMAIL}" \
    --redirect

  resolve_ssl_paths
  create_user_ssl_files

  if nginx -t; then
    systemctl reload nginx
    ok "SSL is enabled: https://${DOMAIN}"
  else
    err "Nginx test failed after Certbot changes."
    exit 1
  fi
}

print_checks() {
  show_service_info "${PORT}" "${APP_HOST}" "${EMAIL}"
  cat <<INFO

If SSL failed, verify:
1. DNS A/AAAA records for ${DOMAIN} point to this server.
2. Ports 80 and 443 are open in firewall/security groups.
3. Nginx is reachable from the public internet.
INFO
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --domain)
        DOMAIN="${2:-}"
        shift 2
        ;;
      --port)
        PORT="${2:-}"
        shift 2
        ;;
      --email)
        EMAIL="${2:-}"
        shift 2
        ;;
      --app-host)
        APP_HOST="${2:-}"
        shift 2
        ;;
      --menu)
        USE_MENU="true"
        shift
        ;;
      --non-interactive)
        NON_INTERACTIVE="true"
        shift
        ;;
      --cleanup-first)
        FORCE_CLEANUP_FIRST="true"
        shift
        ;;
      --cleanup-only)
        CLEANUP_ONLY="true"
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        err "Unknown argument: $1"
        usage
        exit 1
        ;;
    esac
  done
}

main() {
  init_output_style
  parse_args "$@"
  require_root
  ensure_state_dir
  load_cache
  detect_server_ip

  if [[ "${NON_INTERACTIVE}" == "true" ]]; then
    apply_noninteractive_cache_defaults
  fi

  if [[ "${NON_INTERACTIVE}" != "true" ]]; then
    setup_tty

    if [[ "${USE_MENU}" == "true" ]]; then
      run_interactive_menu
    elif [[ $# -eq 0 && -z "${DOMAIN}" && -z "${PORT}" && -z "${EMAIL}" ]]; then
      # Default to menu for no-argument interactive runs.
      run_interactive_menu
    else
      prompt_if_missing
    fi
  fi

  validate_inputs
  install_packages_if_needed
  resolve_nginx_paths
  handle_existing_installation
  enforce_domain_port_uniqueness
  write_nginx_config
  request_certificate
  save_cache
  save_registry_entry
  print_checks
}

main "$@"
